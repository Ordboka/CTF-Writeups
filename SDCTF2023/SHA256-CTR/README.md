# SHA256-CTR (Crypto 400 points)
**Keywords: Hash, length extension, SHA256**

## Understanding the cipher

Looking at the code given we can see that it implements a cipher that xor's the given plaintext with the hash of a counter. The counter gets increased by one for each block that is encrypted and therefore the same key is never used twice for encrypting. Since it is the hash of the counter we are encrypting with there is also no relations between the consecutive keys we can use.

## Understanding what we are given

When first running the code we are given three options. The first option is to encrypt the flag. This uses the cipher described above to encrypt the flag. To decrypt it we therefore need to in some way figure out what the flag is being xored with so we can decrypt it with the same key.

The second option is to encrypt any message we choose. This is great as we can use this to get the hash of a counter value by making the message the all zero message.

The third option lets us increase the counter by as much as we want. In theory this is just the same as asking the service to encrypt some message a number of times, but in practice this lets us increase the counter by a lot more than what would otherwise be feasible. The code also gives us a hint through a developer hint that this might be the part we should try to exploit.

## Breaking the cipher

To get the flag we will need to encrypt the flag with a key that we can figure out. My first idea was to try to increase the counter with a negative number to make the server reuse the same key, but the server sadly checks for this.

From the code we can see that when converting the counter to bytes it is specified to use little endian, despite the default being big endian. For me this was a clue to investigate this part a bit more. Because little endian is used this means that if we increase the counter with a big power of two, the start of the message to hash would still be the same.

My next attempt was therefore to try to increase the counter with 2<sup>512</sup> in the hope that this would magically make the SHA256 return the same value as before because of overflow or something, but this is of course not how SHA256 works. When the message becomes too long for one SHA256 block it uses a techinque where it first hashes the first block, then uses the output of this in combination with the second block to generate a new hash, and so forth for all the blocks until a final hash is produced.

Since the second block only relies on the hash of the first block and not the actual contents of it we can utilize a length extension attack to figure out what the hash of a longer message is, despite not knowing what is in the start of the message. For a very good explanation of how this works, see the [Hash extender](https://github.com/iagox86/hash_extender) library. This library can also be used to generate the actual hash.

Now that I knew how a length extension attack worked my plan was simple. 
1. Get the original hash of a counter by encrypting my own message of all zeros
2. Increase the counter by an amount such that the next counter used gives a hash where the first block is the same as in 1. and where we know what the second block is
3. Encrypt the flag. This will now use the key as the hash we can calculate
4. Decrypt flag

Now the only thing left to figure out is what to increase the counter with to actually make the first block the same as before. Because of the way SHA256 adds padding we can't simply add 2<sup>512</sup> to the counter, we also need to add the bits used by the padding in the original message. To figure out what these were I used the excellent [Sha256algorithm visualizer](https://sha256algorithm.com/) which not only goes into detail about all the steps of SHA256, but also shows the bits of padding. From just giving it a random value generated by the code locally I saw that I would need to add a one in the 263rd position to signify the start of the padding (I was at first a bit confused since the website shows 8 bit blocks so bit 263 is right after 248 visually, but I figured it out eventually). I also needed to add a bit in the 496th position to account for the bit added in SHA256 to show the length of the message. In addition to this I added 2<sup>512</sup> to make the second block consist of a single 1. In addition I had to subtract the number of message I had already sent. Therefore in total I would ask the server to increase its counter by 2<sup>263</sup> + 2<sup>496</sup> + 2<sup>512</sup> - (n_messages).

Now I could use [HashPumpy](https://pypi.org/project/hashpumpy/) to figure out what the hash of this counter would be. There were a few things with the library that confused me. The first was a mysterious error message I received when trying to run the package. `SystemError: PY_SSIZE_T_CLEAN macro must be defined for '#' formats`. I found out that this was because I was using too new of a version of Python to run it. When I tried with Python 3.9 everything was okay. The second was that I didn't have to specify that I was using SHA256 even though it could also perform the same attack for other hashing algorithms. I figured out that this is because all the different algorithms have different hash sizes so it could figure it out implicitly. The third thing was that it required me to add some data from the original hash and it would not take the empty string as an input. I dealt with this by reducing the key length by one and just putting something random to add. I thought I would have to guess what the last byte was, but for some reason the choice did not make any difference.

With the hash in hand and the flag encrypted with the same hash all that was left to do now was to decrypt the flag.

Because the flag was two blocks long I actually had to figure out two hashes, and remember to perform xor properly when the hex I was given was not as long as the key. But when I figured all of this out I could submit the flag.

A solve script can be found in [solve.py](solve.py)